// Mocks generated by Mockito 5.0.10 from annotations
// in tatsam_app_experimental/test/core/voicenotes/data/repositories/voice-note-player-repository-impl_test.dart.
// Do not manually edit this file.

import 'dart:async' as _i3;
import 'dart:typed_data' as _i5;

import 'package:flutter_sound/public/flutter_sound_player.dart' as _i2;
import 'package:flutter_sound_platform_interface/flutter_sound_platform_interface.dart'
    as _i4;
import 'package:mockito/mockito.dart' as _i1;
import 'package:tatsam_app_experimental/core/platform/network_info.dart' as _i6;

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: comment_references
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis

/// A class which mocks [FlutterSoundPlayer].
///
/// See the documentation for Mockito's code generation for more information.
class MockFlutterSoundPlayer extends _i1.Mock
    implements _i2.FlutterSoundPlayer {
  MockFlutterSoundPlayer() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.PlayerState get playerState =>
      (super.noSuchMethod(Invocation.getter(#playerState),
          returnValue: _i2.PlayerState.isStopped) as _i2.PlayerState);
  @override
  bool get isPlaying =>
      (super.noSuchMethod(Invocation.getter(#isPlaying), returnValue: false)
          as bool);
  @override
  bool get isPaused =>
      (super.noSuchMethod(Invocation.getter(#isPaused), returnValue: false)
          as bool);
  @override
  bool get isStopped =>
      (super.noSuchMethod(Invocation.getter(#isStopped), returnValue: false)
          as bool);
  @override
  void updateProgress({int? duration = 0, int? position = 0}) => super
      .noSuchMethod(
          Invocation.method(
              #updateProgress, [], {#duration: duration, #position: position}),
          returnValueForMissingStub: null);
  @override
  void pause(int? state) =>
      super.noSuchMethod(Invocation.method(#pause, [state]),
          returnValueForMissingStub: null);
  @override
  void resume(int? state) =>
      super.noSuchMethod(Invocation.method(#resume, [state]),
          returnValueForMissingStub: null);
  @override
  void skipBackward(int? state) =>
      super.noSuchMethod(Invocation.method(#skipBackward, [state]),
          returnValueForMissingStub: null);
  @override
  void skipForward(int? state) =>
      super.noSuchMethod(Invocation.method(#skipForward, [state]),
          returnValueForMissingStub: null);
  @override
  void updatePlaybackState(int? state) =>
      super.noSuchMethod(Invocation.method(#updatePlaybackState, [state]),
          returnValueForMissingStub: null);
  @override
  void needSomeFood(int? ln) =>
      super.noSuchMethod(Invocation.method(#needSomeFood, [ln]),
          returnValueForMissingStub: null);
  @override
  void audioPlayerFinished(int? state) =>
      super.noSuchMethod(Invocation.method(#audioPlayerFinished, [state]),
          returnValueForMissingStub: null);
  @override
  void openPlayerCompleted(int? state, bool? success) => super.noSuchMethod(
      Invocation.method(#openPlayerCompleted, [state, success]),
      returnValueForMissingStub: null);
  @override
  void closePlayerCompleted(int? state, bool? success) => super.noSuchMethod(
      Invocation.method(#closePlayerCompleted, [state, success]),
      returnValueForMissingStub: null);
  @override
  void pausePlayerCompleted(int? state, bool? success) => super.noSuchMethod(
      Invocation.method(#pausePlayerCompleted, [state, success]),
      returnValueForMissingStub: null);
  @override
  void resumePlayerCompleted(int? state, bool? success) => super.noSuchMethod(
      Invocation.method(#resumePlayerCompleted, [state, success]),
      returnValueForMissingStub: null);
  @override
  void startPlayerCompleted(int? state, bool? success, int? duration) =>
      super.noSuchMethod(
          Invocation.method(#startPlayerCompleted, [state, success, duration]),
          returnValueForMissingStub: null);
  @override
  void stopPlayerCompleted(int? state, bool? success) => super.noSuchMethod(
      Invocation.method(#stopPlayerCompleted, [state, success]),
      returnValueForMissingStub: null);
  @override
  bool isOpen() =>
      (super.noSuchMethod(Invocation.method(#isOpen, []), returnValue: false)
          as bool);
  @override
  _i3.Future<_i2.FlutterSoundPlayer?> openAudioSession(
          {_i4.AudioFocus? focus = _i4.AudioFocus.requestFocusAndKeepOthers,
          _i4.SessionCategory? category = _i4.SessionCategory.playAndRecord,
          _i4.SessionMode? mode = _i4.SessionMode.modeDefault,
          _i4.AudioDevice? device = _i4.AudioDevice.speaker,
          int? audioFlags = 49,
          bool? withUI = false}) =>
      (super.noSuchMethod(
              Invocation.method(#openAudioSession, [], {
                #focus: focus,
                #category: category,
                #mode: mode,
                #device: device,
                #audioFlags: audioFlags,
                #withUI: withUI
              }),
              returnValue: Future<_i2.FlutterSoundPlayer?>.value())
          as _i3.Future<_i2.FlutterSoundPlayer?>);
  @override
  _i3.Future<_i2.FlutterSoundPlayer?> openAudioSessionWithUI(
          {_i4.AudioFocus? focus = _i4.AudioFocus.requestFocusAndKeepOthers,
          _i4.SessionCategory? category = _i4.SessionCategory.playAndRecord,
          _i4.SessionMode? mode = _i4.SessionMode.modeDefault,
          _i4.AudioDevice? device = _i4.AudioDevice.speaker,
          int? audioFlags = 49}) =>
      (super.noSuchMethod(
              Invocation.method(#openAudioSessionWithUI, [], {
                #focus: focus,
                #category: category,
                #mode: mode,
                #device: device,
                #audioFlags: audioFlags
              }),
              returnValue: Future<_i2.FlutterSoundPlayer?>.value())
          as _i3.Future<_i2.FlutterSoundPlayer?>);
  @override
  _i3.Future<void> setAudioFocus(
          {_i4.AudioFocus? focus = _i4.AudioFocus.requestFocusAndKeepOthers,
          _i4.SessionCategory? category = _i4.SessionCategory.playback,
          _i4.SessionMode? mode = _i4.SessionMode.modeDefault,
          _i4.AudioDevice? device = _i4.AudioDevice.speaker,
          int? audioFlags = 45}) =>
      (super.noSuchMethod(
          Invocation.method(#setAudioFocus, [], {
            #focus: focus,
            #category: category,
            #mode: mode,
            #device: device,
            #audioFlags: audioFlags
          }),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> closeAudioSession() =>
      (super.noSuchMethod(Invocation.method(#closeAudioSession, []),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<_i2.PlayerState> getPlayerState() => (super.noSuchMethod(
          Invocation.method(#getPlayerState, []),
          returnValue: Future<_i2.PlayerState>.value(_i2.PlayerState.isStopped))
      as _i3.Future<_i2.PlayerState>);
  @override
  _i3.Future<Map<String, Duration>> getProgress() =>
      (super.noSuchMethod(Invocation.method(#getProgress, []),
              returnValue:
                  Future<Map<String, Duration>>.value(<String, Duration>{}))
          as _i3.Future<Map<String, Duration>>);
  @override
  _i3.Future<bool> isDecoderSupported(_i4.Codec? codec) =>
      (super.noSuchMethod(Invocation.method(#isDecoderSupported, [codec]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<void> setSubscriptionDuration(Duration? duration) => (super
      .noSuchMethod(Invocation.method(#setSubscriptionDuration, [duration]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<Duration?> startPlayer(
          {String? fromURI,
          _i5.Uint8List? fromDataBuffer,
          _i4.Codec? codec = _i4.Codec.aacADTS,
          int? sampleRate = 16000,
          int? numChannels = 1,
          _i2.TWhenFinished? whenFinished}) =>
      (super.noSuchMethod(
          Invocation.method(#startPlayer, [], {
            #fromURI: fromURI,
            #fromDataBuffer: fromDataBuffer,
            #codec: codec,
            #sampleRate: sampleRate,
            #numChannels: numChannels,
            #whenFinished: whenFinished
          }),
          returnValue: Future<Duration?>.value()) as _i3.Future<Duration?>);
  @override
  _i3.Future<void> startPlayerFromMic(
          {int? sampleRate = 44000, int? numChannels = 1}) =>
      (super.noSuchMethod(
          Invocation.method(#startPlayerFromMic, [],
              {#sampleRate: sampleRate, #numChannels: numChannels}),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> startPlayerFromStream(
          {_i4.Codec? codec = _i4.Codec.pcm16,
          int? numChannels = 1,
          int? sampleRate = 16000}) =>
      (super.noSuchMethod(
          Invocation.method(#startPlayerFromStream, [], {
            #codec: codec,
            #numChannels: numChannels,
            #sampleRate: sampleRate
          }),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> feedFromStream(_i5.Uint8List? buffer) =>
      (super.noSuchMethod(Invocation.method(#feedFromStream, [buffer]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<Duration?> startPlayerFromTrack(_i2.Track? track,
          {_i2.TonSkip? onSkipForward,
          _i2.TonSkip? onSkipBackward,
          _i2.TonPaused? onPaused,
          _i2.TWhenFinished? whenFinished,
          Duration? progress,
          Duration? duration,
          bool? defaultPauseResume,
          bool? removeUIWhenStopped = true}) =>
      (super.noSuchMethod(
          Invocation.method(#startPlayerFromTrack, [
            track
          ], {
            #onSkipForward: onSkipForward,
            #onSkipBackward: onSkipBackward,
            #onPaused: onPaused,
            #whenFinished: whenFinished,
            #progress: progress,
            #duration: duration,
            #defaultPauseResume: defaultPauseResume,
            #removeUIWhenStopped: removeUIWhenStopped
          }),
          returnValue: Future<Duration?>.value()) as _i3.Future<Duration?>);
  @override
  _i3.Future<void> nowPlaying(_i2.Track? track,
          {Duration? duration,
          Duration? progress,
          _i2.TonSkip? onSkipForward,
          _i2.TonSkip? onSkipBackward,
          _i2.TonPaused? onPaused,
          bool? defaultPauseResume}) =>
      (super.noSuchMethod(
          Invocation.method(#nowPlaying, [
            track
          ], {
            #duration: duration,
            #progress: progress,
            #onSkipForward: onSkipForward,
            #onSkipBackward: onSkipBackward,
            #onPaused: onPaused,
            #defaultPauseResume: defaultPauseResume
          }),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> stopPlayer() =>
      (super.noSuchMethod(Invocation.method(#stopPlayer, []),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> pausePlayer() =>
      (super.noSuchMethod(Invocation.method(#pausePlayer, []),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> resumePlayer() =>
      (super.noSuchMethod(Invocation.method(#resumePlayer, []),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> seekToPlayer(Duration? duration) =>
      (super.noSuchMethod(Invocation.method(#seekToPlayer, [duration]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> setVolume(double? volume) =>
      (super.noSuchMethod(Invocation.method(#setVolume, [volume]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> setUIProgressBar({Duration? duration, Duration? progress}) =>
      (super.noSuchMethod(
          Invocation.method(#setUIProgressBar, [],
              {#duration: duration, #progress: progress}),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future.value()) as _i3.Future<void>);
  @override
  _i3.Future<String?> getResourcePath() =>
      (super.noSuchMethod(Invocation.method(#getResourcePath, []),
          returnValue: Future<String?>.value()) as _i3.Future<String?>);
}

/// A class which mocks [NetworkInfo].
///
/// See the documentation for Mockito's code generation for more information.
class MockNetworkInfo extends _i1.Mock implements _i6.NetworkInfo {
  MockNetworkInfo() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<bool> get isConnected =>
      (super.noSuchMethod(Invocation.getter(#isConnected),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
}
